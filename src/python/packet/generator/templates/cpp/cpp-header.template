<%inherit file="cpp-base.template" />\

<%block name="header">\
// Automatically generated by Packet C++ code generator.

#ifndef ${self.header_macro()}
#define ${self.header_macro()}

${self.common_include()}\

% for packet in pom.includes.values():
${self.include(packet.namespace)}
% endfor
</%block>\

% for name, enum in pom.enums.iteritems():
enum class ${name} {
  % for name, item in enum.items.iteritems():
  ${name} = ${item.value},
  % endfor
};

% endfor

% for name, packet in pom.packets.iteritems():
<%
  cpp_class_name = self.class_name(packet)
  cpp_parent_class = self.get_parent(packet)
%>\
class ${cpp_class_name} : public ${self.get_parent(packet)} {
 public:
  enum class SubPackets {
  % for p in packet.children:
    ${self.class_name(p).upper()},
  % endfor
  };

  ${self.lvalue_iovector_constructor_prototype(packet)};
  ${self.rvalue_iovector_constructor_prototype(packet)};
  ${self.size_constructor_prototype(packet, packet.min_size)};

  ${self.copy_constructor_prototype(packet)} = default;
  ${self.move_constructor_prototype(packet)} = default;

  virtual ~${cpp_class_name}();

  ${self.init_method_decl(packet)}

% for field in packet.fields:
  ${self.getter_decl(field)}
  ${self.setter_decl(field)}
% endfor

  ${self.size_decl(packet)}
  ${self.static_size_decl(packet)}

% for field in packet.fields:
  ${self.static_getter_decl(field)}
  ${self.static_setter_decl(field)}
% endfor

 protected:
% for field in packet.fields:
  ${self.offset_decl(field)}
  % if not field.has_fixed_size():
  ${self.field_size_decl(field)}
  % endif
% endfor

 private:
  const static size_t MIN_SIZE = ${packet.min_size};
};

% endfor
\
<%def name="getter_decl(field)" buffered="True" filter="trim">
  ${self.getter_prototype(field)};
</%def>\
\
<%def name="static_getter_decl(field)" buffered="True" filter="trim">
  ${self.static_getter_prototype(field)};
</%def>\
\
<%def name="setter_decl(field)" buffered="True" filter="trim">
  ${self.setter_prototype(field)};
</%def>\
\
<%def name="static_setter_decl(field)" buffered="True" filter="trim">
  ${self.static_setter_prototype(field)};
</%def>\
\
<%def name="offset_decl(field)" buffered="True" filter="trim">
  ${self.offset_prototype(field)};
</%def>\
\
<%def name="field_size_decl(packet)" buffered="True" filter="trim">
  ${self.field_size_prototype(packet)};
</%def>\
\
<%def name="size_decl(packet)" buffered="True" filter="trim">
  virtual ${self.size_prototype(packet)};
</%def>\
\
<%def name="static_size_decl(packet)" buffered="True" filter="trim">
  ${self.static_size_prototype(packet)};
</%def>\
\
<%def name="header_macro()" buffered="True" filter="trim">
  ${'PACKET_GEN_%s_' % pom.namespace.upper()}
</%def>\
\
<%def name="init_method_decl(packet)" buffered="True" filter="trim">
  ${self.init_method_prototype(packet)};
</%def>\

<%block name="footer">
% for name, packet in pom.packets.iteritems():
% for p in packet.children:
${self.namespace_open(p.pom)}
class ${self.class_name(p)};
${self.namespace_close(p.pom)}
% endfor
% endfor

namespace cyrus {
namespace concurrency {
namespace internal {

% for name, packet in pom.packets.iteritems():
<%
  cpp_class_name = self.class_name(packet, qualified=True)
%>\

template <typename Actor>
struct emit_message_functor<${cpp_class_name}, Actor> {
  bool operator()(const ${cpp_class_name}& data,
      const std::shared_ptr<Context>& context,
      const std::shared_ptr<Actor>& actor) {
    % for p in packet.children:
    if (${self.type_selector_cond(p, 'data')}) {
      auto casted_data = dynamic_cast<const ${
          self.class_name(p, qualified=True)}*>(&data);
      return
          emit_message_functor<${self.class_name(p, qualified=True)}, Actor>()(
              *casted_data, context, actor) |
          ## This is an optimization for polymorphic messages.
          do_emit_message(data, context, actor);
    }
    % endfor
    return do_emit_message(data, context, actor);
  }
};


template <>
MessageSerializer* get_default_serializer<${cpp_class_name}>(
    SerializationManager* manager);

% endfor

}  // namespace internal
}  // namespace concurrency
}  // namespace cyrus

#endif  // ${self.header_macro()}
</%block>
