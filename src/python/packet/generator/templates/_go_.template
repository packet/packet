<%!
  from packet.types import BuiltInType
  from packet.generator.go import BUILTIN_TYPES
%>

<%block name="header">\
// Automatically generated by Packet Go code generator.
package ${pom.namespace}

import (
  "bytes"
  "encoding/binary"
  "errors"
  "fmt"
  "io"
  "net"

  "github.com/packet/packet/src/go/packet"

  % for packet in pom.includes.values():
    % if include_prefix:
      % if include_prefix[0][-1] == '/':
  "${include_prefix[0][:-1]}/${packet.namespace}"
      % else:
  "${include_prefix[0]}/${packet.namespace}"
      % endif
    % else:
  "../${packet.namespace}"
    % endif
  % endfor
)
</%block>\
\
<%block name="src">\
% for name, enum in pom.enums.iteritems():

type ${name} int

const (
  % for item_name, item in enum.items.iteritems():
  ${item_name} ${name} = ${item.value}
  % endfor
)
% endfor
% for name, packet in pom.packets.iteritems():

<%
  ctor = self.slice_constructor(packet, pom.namespace)
%>\
func ${ctor}(b []byte) ${self.type(packet, pom.namespace)} {
  return ${self.struct_init(packet, pom.namespace, 'b')}
}

func ${self.default_constructor(packet, pom.namespace)}() ${
    self.type(packet, pom.namespace)} {
  % if packet.get_padding_info():
  s := packet.PaddedSize(${packet.min_size}, ${
                         packet.get_padding_info().multiple})
  % else:
  s := ${packet.min_size}
  % endif
  b := make([]byte, s)
  p := ${self.struct_init(packet, pom.namespace, 'b')}
  p.Init()
  return p
}

type ${name} struct {
  ${self.parent(packet, False)}
}

func (this ${name}) minSize() int {
  return ${packet.min_size}
}

func (this ${name}) Clone() (${name}, error) {
  var newBuf bytes.Buffer
  _, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
  if err != nil {
    return ${self.default_constructor(packet, pom.namespace)}(), err
  }

  return ${ctor}(newBuf.Bytes()), nil
}

type ${name}Conn struct {
  net.Conn
  buf []byte
  offset int
}

func New${name}Conn(c net.Conn) ${name}Conn {
  return ${name}Conn {
    Conn: c,
    buf: make([]byte, packet.DefaultBufSize),
  }
}

func (c *${name}Conn) Write(pkts []${name}) error {
  for _, p := range pkts {
    s := p.Size()
    b := p.Buffer()[:s]
    n := 0
    for s > 0 {
      var err error
      if n, err = c.Conn.Write(b); err != nil {
        return fmt.Errorf("Error in write: %v", err)
      }
      s -= n
    }
  }
  return nil
}

func (c *${name}Conn) Read(pkts []${name}) (int, error) {
  if len(c.buf) == c.offset {
    newSize := packet.DefaultBufSize
    if newSize < len(c.buf) {
      newSize = 2 * len(c.buf)
    }

    buf := make([]byte, newSize)
    copy(buf, c.buf[:c.offset])
    c.buf = buf
  }

  r, err := c.Conn.Read(c.buf[c.offset:])
  if err != nil {
    return 0, err
  }

  r += c.offset

  s := 0
  n := 0
  for i := range pkts {
    p := ${ctor}(c.buf[s:])

    pSize := p.Size()
    if r < s+pSize {
      break
    }

    pkts[i] = p
    s += pSize
    n++
  }

  c.offset = r - s
  if c.offset < 0 {
    panic("Invalid value for offset")
  }

  c.buf = c.buf[s:]
  return n, nil
}

func (this *${name}) Init() {
  % if packet.parent:
  this.${packet.parent.name}.Init()
  % endif
  % if packet.get_size_field():
  this.${self.setter(packet.get_size_field())}(${
      self.type(packet.get_size_field().type, pom.namespace)
      }(this.minSize()))
  % endif
  // Invariants.
  % for field, value in packet.get_type_selector_condition(True):
  this.${self.setter(field)}(${
      self.type(field.type, pom.namespace)}(${value})) // ${field.name}
  % endfor
}

func (this ${name}) Size() int {
  % if packet.is_const_size():
  return ${packet.get_const_size()}
  % else:
  if len(this.Buf) < this.minSize() {
    return 0
  }

  size := int(this.${self.getter(packet.get_size_field())}())
    % if not packet.is_padded():
  return size
    % else:
  return packet.PaddedSize(size, ${packet.get_padding_info().multiple})
    % endif
  % endif
}

func To${name}(p ${self.parent(packet)}) (${
    self.type(packet, pom.namespace, None, false)}, error) {
  if !Is${name}(p) {
    return ${ctor}(nil), errors.New("Cannot convert to ${
        self.type(packet, false)}")
  }

  return ${ctor}(p.Buf), nil
}

func Is${name}(p ${self.parent(packet)}) bool {
  return ${self.type_selector_cond(packet, 'p')}
}
\
% for field in packet.fields:
<%
getter_type = self.type(field.type, pom.namespace, field.repeated_info)
%>
func (this *${name}) ${self.getter(field)}() ${getter_type} {
  offset := this.${self.offset(field)}()
  % if field.is_repeated():
  packet_size := this.Size()
    % if field.get_size_field():
  size := int(this.${self.getter(field.get_size_field())}())
    % else:
  size := packet_size - offset
    % endif
    % if field.get_count_field():
  count := int(this.${self.getter(field.get_count_field())}())
    % elif field.is_const_size_repeated():
  count := ${field.repeated_info.count}
    % else:
  count := this.Size() - offset
    % endif
    % if field.is_const_size_repeated():
  i := 0
    % endif
  var res ${getter_type}
  for size > 0 && count > 0 && packet_size > offset {
    ${self.read_field(field, 'offset', 'elem')}
    % if isinstance(field.type, BuiltInType):
    if size < ${field.type.length_in_bytes} {
      break
    }
    size -= ${field.type.length_in_bytes}
    offset += ${field.type.length_in_bytes}
    % else:
    if elem.Size() > size {
      break
    }
    size -= elem.Size()
    offset += elem.Size()
    % endif
    count--
    % if field.is_const_size_repeated():
    res[i] = elem
    i++
    % else:
    res = append(res, elem)
    % endif
  }
  return res
  % else:
  ${self.read_field(field, 'offset', 'res')}
  return res
  % endif
}
<%
if field.is_dynamic_repeated():
  setter_type = self.type(field.type, packet.pom.namespace)
else:
  setter_type = self.type(field.type, packet.pom.namespace, field.repeated_info)

val = field.name[0]
%>
func (this *${name}) ${self.setter(field)}(${val} ${setter_type}) {
  offset := this.${self.offset(field)}()
  % if field.is_dynamic_repeated():
  offset += this.${self.field_size(field)}()
    % if isinstance(field.type, BuiltInType):
  size := ${field.type.length_in_bytes}
    % else:
  size := ${val}.Size()
    % endif
  this.OpenGap(offset, size)
  this.${self.setter(packet.get_size_field())}(${
      BUILTIN_TYPES[packet.get_size_field().type.name]}(this.Size() + size))
  ${self.write_field(field, 'offset', val)}
    % if field.get_count_field():
  count := this.${self.getter(field.get_count_field())}()
  this.${self.setter(field.get_count_field())}(count + 1)
    % elif field.get_size_field():
  this.${self.setter(field.get_size_field())}(this.${
      self.getter(field.get_size_field())}() + ${
      BUILTIN_TYPES[field.get_size_field().type.name]}(size))
    % endif
\
  % elif field.is_const_size_repeated():
  for _, e := range ${val} {
    ${self.write_field(field, 'offset', 'e')}
  }
\
  % elif not field.has_const_size() and not field.is_repeated():
  if this.${self.field_size(field)}() != 0 {
    panic("Repeated field ${field.name} is already set.")
  }
  size := ${val}.Size()
  this.${self.setter(packet.get_size_field())}(${
      BUILTIN_TYPES[packet.get_size_field().type.name]}(this.Size() + size))
  this.OpenGap(offset, size)
  ${self.write_field(field, 'offset', val)}
  % elif packet.is_padded() and not packet.get_padding_info().excluded and packet.get_size_field() == field:
  ${val} = ${BUILTIN_TYPES[field.type.name]}(packet.PaddedSize(int(${val}), ${
      packet.get_padding_info().multiple}))
  ${self.write_field(field, 'offset', val)}
  % else:
  ${self.write_field(field, 'offset', val)}
  % endif
}

func (this *${name}) ${self.offset(field)}() int {
  offset := ${field.offset[0]}
  % for offset_field in field.offset[1]:
  offset += this.${self.field_size(offset_field)}()
  % endfor
  return offset
}

  % if not field.has_const_size():
func (this *${name}) ${self.field_size(field)}() int {
    % if not field.is_repeated():
  offset := this.${self.offset(field)}()
  if offset >= this.Size() {
    return 0
  }
  return this.${self.getter(field)}().Size()
    % elif field.get_size_field():
  return int(this.${self.getter(field.get_size_field())}())
    % else:
      % if field.has_implicit_size():
  offset := this.${self.offset(field)}()
  return this.Size() - offset
      % elif field.get_count_field():
  size := 0
  for _, r := range this.${self.getter(field)}() {
    size += r.Size()
  }
  return size
      % endif
    % endif
}
  % endif
% endfor
% endfor
</%block>\
\
<%def name="slice_constructor(packet, cur_ns)" buffered="True" filter="trim">
  % if cur_ns == packet.pom.namespace:
    New${packet.name}WithBuf
  % else:
    ${packet.pom.namespace}.New${packet.name}WithBuf
  % endif
</%def>\
\
<%def name="default_constructor(packet, cur_ns)" buffered="True" filter="trim">
  % if cur_ns == packet.pom.namespace:
    New${packet.name}
  % else:
    ${packet.pom.namespace}.New${packet.name}
  % endif
</%def>\
\
<%def name="parent(packet, pointer=False)" buffered="True" filter="trim">
  % if packet.parent:
    ${self.type(packet.parent, packet.pom.namespace, None, pointer)}
  % else:
    packet.Packet
  % endif
</%def>\
\
<%def name="type(t, cur_ns, repeated_info=None, pointer=False)"
      buffered="True" filter="trim">
  <%
    if isinstance(t, BuiltInType):
      name = BUILTIN_TYPES[t.name]
    elif t.pom.namespace == cur_ns:
      name = t.name
    else:
      name = '%s.%s' % (t.pom.namespace, t.name)
    endif

    if not isinstance(t, BuiltInType) and pointer:
      name = '*' + name

    if repeated_info:
      if repeated_info.count:
        name = '[%d]%s' % (repeated_info.count, name)
      else:
        name = '[]' + name
  %>
  ${name}
</%def>\
\
<%def name="offset(f)" buffered="True" filter="trim">
  ${self.field_name(f.name)}Offset
</%def>\
\
<%def name="field_size(f)" buffered="True" filter="trim">
  ${self.field_name(f.name)}Size
</%def>\
\
<%def name="getter(f)" buffered="True" filter="trim">
  ${self.field_name(f.name)}
</%def>\
\
<%def name="setter(f)" buffered="True" filter="trim">
  % if f.repeated_info and not f.repeated_info.count:
  Add${self.field_name(f.name)}
  % else:
  Set${self.field_name(f.name)}
  % endif
</%def>\
\
<%def name="field_name(f)" buffered="True" filter="trim">
  ${''.join([p.capitalize() for p in f.split('_')])}
</%def>\
\
<%def name="read_field(field, offset, res)" buffered="True" filter="trim">
  % if isinstance(field.type, BuiltInType) and field.type.length_in_bytes == 1:
    ${res} := ${BUILTIN_TYPES[field.type.name]}(this.Buf[${offset}])
  % elif isinstance(field.type, BuiltInType):
    <%
      endian = 'BigEndian' if field.packet.big_endian else 'LittleEndian'
      method = BUILTIN_TYPES[field.type.name].capitalize()
    %>
    ${res} := binary.${endian}.${method}(this.Buf[${offset}:])
  % else:
    ${res} := ${self.slice_constructor(field.type, field.packet.pom.namespace)
        }(this.Buf[${offset}:])
  % endif
</%def>\
\
<%def name="write_field(field, offset, val)" buffered="True" filter="clean_ws">
  % if isinstance(field.type, BuiltInType) and field.type.length_in_bytes == 1:
    this.Buf[${offset}] = byte(${val}); offset++
  % elif isinstance(field.type, BuiltInType):
    <%
      endian = 'BigEndian' if field.packet.big_endian else 'LittleEndian'
      method = 'Put' + BUILTIN_TYPES[field.type.name].capitalize()
    %>
    binary.${endian}.${method}(this.Buf[${offset}:], ${val});
    offset += ${field.type.length_in_bytes}
  % else:
    copy(this.Buf[offset:], ${val}.Buf[:${val}.Size()]); offset += ${val}.Size()
  % endif
</%def>\
\
<%def name="struct_init(p, cur_ns, buf)" buffered="True" filter="trim">
  <% t = self.type(p, cur_ns, None, False) %>
  % if p.parent:
  ${t}{${self.struct_init(p.parent, cur_ns, buf)}}
  % else:
  ${t}{packet.Packet{Buf: ${buf}}}
  % endif
</%def>\
\
<%!
  def clean_ws(txt):
    return ' '.join(txt.strip().split())
%>
<%def name="type_selector_cond(packet, var='this')" buffered="True"
      filter="clean_ws">
  % if packet.parent:
    <%
      conditions = packet.get_type_selector_condition()
      assert conditions, 'Type selector cannot be empty for %s' % packet.name
    %>
    % for field, value in conditions:
      ${var}.${self.getter(field)}() == ${value} &&
    % endfor
  % endif
  true
</%def>\
